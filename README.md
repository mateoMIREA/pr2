# Интеллектуальные системы и технологии

# Практическая работа №2

**Центральность в графе.**

**Тема — определение центральности в графе среди своих друзей ВКонтакте.**

---

## Цель работы
Сбор данных из социальной сети ВКонтакте, построение графа социальных связей и комплексный анализ центральности вершин для выявления наиболее влиятельных пользователей в сети.

## Описание кода

### Часть 1: Сбор данных из VK API

**Основные функции:**
1. **`get_user_info()`** - получение информации о пользователе по ID
2. **`make_dict_from_user_info()`** - структурирование данных пользователя
3. **`request_friends()`** - получение списка друзей пользователя
4. **`make_node_from_user_info()`** - преобразование в узел графа
5. **`write_to_txt()`** - сохранение данных в файлы

**Логика работы:**
- Аутентификация через VK API токен
- Сбор данных о пользователе и его социальных связях
- Построение трехуровневой структуры графа:
  - "me" - основной пользователь (желтый)
  - "friend" - прямые друзья (синий) 
  - "friend_of_friend" - друзья друзей (зеленый)
- Сохранение в файлы `nodes.txt` и `edges.txt`

### Часть 2: Визуализация графа

**Используемые библиотеки:**
- `networkx` - работа с графами
- `matplotlib` - визуализация
- `collections` - дополнительные структуры данных

**Логика работы:**
- Чтение данных из файлов `nodes.txt` и `edges.txt`
- Создание графа с помощью `nx.Graph()`
- Добавление узлов и рёбер в граф
- Настройка цветовой схемы по типам пользователей
- Визуализация графа с алгоритмом Камады-Каваи для оптимального расположения узлов

### Часть 3: Анализ центральности

**Реализованные метрики центральности:**

1. **Betweenness Centrality (Посредническая центральность)**
   - **Алгоритм**: Модифицированный алгоритм Брандса
   - **Логика**: Измеряет, как часто узел появляется на кратчайших путях между другими узлами
   - **Формула**: `σ(s,t|v)/σ(s,t)` - доля кратчайших путей, проходящих через узел
   - **Нормализация**: Деление на `(n-1)(n-2)` для неориентированных графов

2. **Closeness Centrality (Близостная центральность)**
   - **Алгоритм**: Поиск в ширину (BFS) от каждого узла
   - **Логика**: Измеряет среднюю близость узла ко всем другим узлам
   - **Формула**: `(достижимые_узлы) / (сумма_расстояний)`
   - **Особенность**: Учитывает только достижимые узлы

3. **Eigenvector Centrality (Центральность по собственному вектору)**
   - **Алгоритм**: Степенной метод (Power iteration)
   - **Логика**: Измеряет влияние узла на основе влияния его соседей
   - **Математика**: Главный собственный вектор матрицы смежности
   - **Параметры**: Максимум 100 итераций, точность 1e-6

**Ключевые особенности реализации:**
- Ручная реализация алгоритмов без использования встроенных функций networkx
- Обработка графов с 188 узлами и 189 рёбрами
- Вывод топ-5 узлов по каждой метрике центральности
- Защита от ошибок (проверка достижимости, сходимости)

## Выводы

### Реализованный функционал:
- Сбор данных через VK API
- Построение трехуровневого графа: центральный пользователь, друзья (1 уровень), друзья друзей (2 уровень)
- Визуализация с цветовой кодировкой: желтый - "me", синий - "friend", зеленый - "friend_of_friend"
- Вычисление трёх метрик центральности с ручной реализацией алгоритмов

### Алгоритмические решения:
- **Betweenness Centrality** - Центральность по посредничеству
- **Closeness Centrality** - Центральность по близости
- **Eigenvector Centrality** - Центральность по собственному вектору

### Результаты анализа:
- Выявлены топ-5 наиболее центральных узлов по каждой метрике
- Betweenness идентифицирует узлы-мосты между сообществами
- Closeness показывает узлы с минимальной средней дистанцией до других
- Eigenvector выделяет узлы, связанные с влиятельными соседями
